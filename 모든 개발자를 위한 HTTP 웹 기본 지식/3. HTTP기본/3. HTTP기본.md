HTTP 기본
 
모든 것이 HTTP(HyperText Transfer Protocol)
- 문서 간의 링크를 통해 연결할 수 있는 / 하이퍼텍스트 문서를 통해서 연결할 수 있는 html <- 이걸 전송하는 프로토콜로 시작
- 지금은 모든 것을  HTTP 메시지로 전송
	- HTML, TEXT
	- 이미지, 음성, 영상, 파일
	- JSON, XML(API)
	- 거의 모든 형태의 데이터
	- 서버 간 데이터를 주고 받을 때도 대부분
	--> 지금은 HTTP 시대(TCP를 직접 연결하는 매우 특수한 경우 외에는 대부분 HTTP 사용)

역사
1. HTTP/0.9 1991: GET메서드만 지원, HTTP 헤더 X
2. HTTP/1.0 1996: 메서드, 헤더 추가
3. HTTP/1.1 1997: 가장 많이 사용 <우리에게 가장 중요한 버전>
4. HTTP/2 2015: 성능 개선
5. HTTP/3 진행중: TCP 대신 UDP 사용, 성능 개선

기반 프로토콜
TCP: HTTP/1.1. HTTP/2
UDP: HTTP/3

특징
- 클라이언트 서버 구조
- 무상태 프로토콜(stateless), 비연결성
- HTTP 메시지
- 단순함, 확장 가능

1. 클라이언트 서버 구조
클라이언트 ---> HTTP 메시지로 요청 ----> 서버
Request Response 구조
: 클라이언트가 서버에 요청 보내고, 응답 대기, 서버가 요청에 대한 결과를 만들어서 응답
- 클라이언트/서버 구조 분리
서버 - 비즈니스 로직, 데이터
클라이언트 - UI, 사용성
--> 클라이언트와 서버가 독립적으로 진화

2. 무상태 프로토콜(Stateless)
= 서버가 클라이언트의 상태를 보존하지 않음
예제
[상태 유지 - statefull]
고객: 이 노트북 얼마인가요?
점원: 100만원 입니다

고객: 2개 구매하겠습니다
점원: 200만원입니다. 신용카드, 현금 중 어떤 걸로 구매하시겠어요?  <노트북, 2개 상태 유지>

고객: 신용카드로 구매하겠습니다
점원: 200만원 결제 완료되었습니다. <노트북, 2개, 신용카드 상태 유지>
----------------------------------------------------------------------------------
[무상태 - stateless]
고객: 이 노트북 얼마인가요?
점원A: 100만원입니다.

고객: 2개 구매하겠습니다. ----------------------------> 노트북 2개 구매하겠습니다.
점원B: ? 무엇을 2개 구매하시겠어요?-----------------> 노트북 2개는 200만원입니다. 신용카드, 현금 중에 어떤 걸로 구매?

고객: 신용카드로 구매하겠습니다.---------------------> 노트북 2개를 신용카드로 구매하겠습니다.
점원C: 무엇을 몇 개 신용카드로 구매하시겠어요?----> 200만원 결제 완료되었습니다.

고객이 필요한 데이터를 그때그때 다 넘김
상태유지: 중간에 다른 점원으로 바뀌면 안된다.(중간에 다른 점원으로 바뀌면 상태 정보를 다른 점원에게 미리 알려줘야 함)
--> 항상 같은 서버가 유지되어야 한다. <서버를 늘리기 어려움, 중간에 서버가 장애났을 때 대응 어려움>
무상태: 중간에 다른 점원으로 바뀌어도 된다.
		- 갑자기 고객이 증가해도 점원을 대거 투입할 수 있다.
		- 갑자기 클라이언트 요청이 증가해도 서버를 대거 투입할 수 있다.
	- 무상태는 응답 서버를 쉽게 바꿀 수 있다. == 무한한 서버 증설 가능
	- 아무 서버가 호출해도 됨
	- 스케일 아웃(=수평 확장 유리)

Stateless 실무 한계
- 모든 것을 무상태로 설계할 수 있는 경우도 있고, 없는 경우도 있다.
(로그인해야되는 경우에는 로그인하고 있는 상태를 유지해야 함.)
- 무상태 --> 로그인이 필요없는 단순한 서비스 소개 화면
- 상태 유지 --> 로그인
- 로그인한 사용자의 경우 로그인 했다는 상태를 서버에 유지
	- 브라우저 쿠키, 서버 세션 등을 사용
- !!상태 유지는 최소한만 사용!!
- 데이터를 많~----이 보내야 함

비연결성
TCP/IP의 경우 연결을 유지함
클라이언트1 -- 서버 연결
클라이언트2 -- 서버 연결 <클라이언트1도 연결 유지>
클라이언트3 -- 서버 연결 <클라이언트1, 2도 연결 유지>
---> 서버는 연결을 계속 유지, 서버 자원 소모

연결 유지X 
클라이언트1 -- 서버 연결
클라이언트1 -- 연결X
클라이언트2 -- 서버 연결 
---> 서버는 연결 유지 안함, 최소한의 자원 사용

HTTP는 기본적으로 연결을 유지하지 않는 모델
- 초 단위 이하의 빠른 속도로 응답
- 1시간동안 수천명이 서비스를 사용해도 실제 서버에서 동시에 처리하는 요청은 수십개 이하로 매우 작음
(예. 검색을 연속적으로 계ㅔㅔㅔㅔ속 하지 않기 때문)
--> 서버 자원을 매우 효율적으로 사용 가능
<단점>
- TCP/IP 연결 새로 맺어야 함 = 3way handshake(SYN(접속요청)메시지 전송 -> 서버가 ACK(요청 수락) 전송 -> 클라이언트가 ACK(요청 수락) 전송 / 데이터 전송) 반복
- 웹브라우저로 사이트 요청시 HTML뿐 아니라 JS, CSS, 추가 이미지 등 수 많은 자원이 함께 다운로드
- 지금 HTTP는 지속 연결로 문제 해결(버전 2, 3에서는 최적화됨)
초기에는 연결/종료,,연결/종료,,연결/종료 반복
지속연결: 연결,,HTML응답,,JS응답,,이미지응답,,종료

HTTP 메시지
HTTP 요청 메시지 예시(요청 메시지도 body 본문을 가질 수 있음)
GET/search?q=hello&hl=ko HTTP/1.1 ----------[start-line]
HOST: www.google.com-------------------------[header]
[empty line]

응답메시지 예시
HTTP/1.1 200 OK -------------------------------[start-line]
Content-Type: text/html;charset=UTF-8--------[header]
Content-Length: 3423---------------------------[header]
[empty line]
<html> ''' </html>------------------------------[body]

구조
[start-line 시작 라인] 
[header 헤더] 
[empty line 공백 라인(CRLF)]
[message body]

시작 라인
= request line / status-line
요청 메시지 -> request line = method SP(공백) request-target SP HTTP-version CRLF(엔터)
 메서드: GET, POST, PUT, DELETE... == 서버가 수행해야 할 동작 지정
GET: 리소스 조회 (리소스를 달라)
POST: 요청 내역 처리(리소스를 줄테니 처리해달라)
요청 대상: absolute-path[?query] = 절대경로[?쿼리]
절대경로: "/"로 시작하는 경로

응답 메시지 - status line
= HTTP-version SP status-code SP reason-phrase CRLF 
status code (상태 코드): 200 = 성공, 400 = 클라이언트 요청 오류, 500 = 서버 내부 오류
reason-phrase 이유 문구: 사람이 읽을 수 있는 상태코드 설명 글

헤더
header-field = field-name":" OWS field-value OWS(띄어쓰기 허용)
용도 
- HTTP 전송에 필요한 모든 부가 정도 포함
ex) 메시지 바디의 내용, 크기, 압축, 인증, 요청 클라이언트의 브라우저 정보, 서버 애플리케이션 정보, 캐시 관리 정보...
- 표준 헤더가 너무 많음
- 필요시 임의의 헤더 추가 가능

메시지 바디
- 실제 전송할 데이터
- 이미지, 영상 HTML문서, JSON 등 byte로 표현하는 모든 데이터

- HTTP는 단순하다, HTTP메시지도 매우 단순
- 크게 성공하는 표준기술은 단순하지만 확장 가능한 기술


정리
- HTTP메시지에 모든 것을 전송
- 버전 1.1 기준으로 학습
- 클라이언트 서버 구조
- 무상태 프로토콜
- HTTP 메시지(시작라인, 헤더, 공백, 바디)
- 단순함, 확장 가능
