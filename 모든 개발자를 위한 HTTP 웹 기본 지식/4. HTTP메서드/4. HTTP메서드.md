HTTP API

회원 정보 관리 API 요구사항
- 회원 목록 조회
- 회원 조회
- 회원 등록
- 회원 수정
- 회원 삭제

API URL 설계
- 회원 목록 조회/read-member-list
- 회원 조회/read-member-by-id
- 회원 등록/create-member
- 회원 수정/update-member
- 회원 삭제/delete-member

--> 좋은 URI 설계일까..?

!!중요한 건 리소스 식별!!

리소스의 의미
: 회원 등록, 수정, 조회는 리소스가 아님!
미네랄을 캔다? 미네랄이 리소스임
= 회원이라는 개념 자체가 리소스임
--> 리소스는 어떻게 식별할까?
- 회원 등록, 수정, 조회는 모두 배제
- 회원이라는 리소스만 식별하면 됨.
-> 회원 리소스를 URI에 매핑


- '회원' 목록 조회/members
- '회원' 조회/members/{id}
- '회원' 등록/members/{id}
- '회원' 수정/members/{id}
- '회원' 삭제/members/{id}
--> 어떻게 구분할까?
cf.계층 구조상 상위를 컬렉션으로 보고 복수단어 사용 권장(memeber -> members)

리소스와 행위를 분리하자
!가장 중요한 것은 리소스를 식별하는 것!
- URI는 리소스만 식별
- 리소스와 해당 리소스를 대상으로 하는 행위를 분리
리소스: 회원
행위: 조회, 등록, 삭제, 변경
- 리소스는 명사, 행위는 동사
- 행위는 어떻게 분리할까?
--->HTTP 메서드 사용(GET, POST, DELETE...)

HTTP 메서드 - GET, POST
:클라이언트가 서버에 뭔가 요청할 때 기대하는 행동
GET: 달라
POST: 데이터를 줄테니 처리해달라

주요 메서드
GET: 리소스 조회
POST: 요청 데이터 처리, 주로 등록에 사용
PUT: 리소스를 대체, 해당 리소스가 없으면 생성
PATCH: 리소스 부분 변경(이름 변경 같은 특정 필드 변경시 사용)
DELETE: 리소스 삭제

기타 메서드
HEAD: GET가 동일하지만 메시지 부분을 제외하고, 상태 줄과 헤더만 반환 (HTTP메시지 구조에서 바디빼고 헤더까지 반환)
OPTIONS: 대상 리소스에 대한 통신 가능 옵션(메서드)을 설명 (주로 COPRS에서 사용)
CONNECT: 대상 자원으로 식별되는 서버에 대한 터널을 설정
TRACE: 대상 리소스에 대한 경로를 따라 메시지 루프백 테스트를 수행
// 거의 사용하지 않으니 참고정도만 하자

GET
: 리소스 조회
- 서버에 전달하고 싶은 데이터는 query(쿼리 파라미터, 쿼리 스트링)를 통해서 전달
- 메시지 바디를 사용해서 데이터를 전달할 수 있지만, 지원하지 않는 곳이 많아서 권장하지 않음.

----------------------------------------------------
ex
[클라이언트]
GET /members/100 HTTP/1.1
Host: localhost:8080

[서버] /members/100에 조회
{
  "username": "young"
  "age": 20
}
----------------------------------------------------
//응답 데이터 전송(서버->클라이언트)
HTTP/1.1 200 OK
Content-type: application/json
Content-Length: 34

{
  "username": "young"
  "age": 20
}

POST
: 요청 데이터 처리
- 메시지 바디를 통해 서버로 요청 데이터 전달
- 서버는 요청 데이터 처리
	- 메시지 바디를 통해 들어온 데이터를 처리하는 모든 기능을 수행한다.
- 주로 전달된 데이터로 신규 리소스 등록, 프로세스 처리에 사용

---------------------------------------------------
EX
[클라이언트]
POST /members HTTP/1.1
Content-Type: application/json

{
  "username": "young"
  "age": 20
}


[서버] /members
--------------------------------------------------
서버에선 데이터 베이스에 등록 --> 신규 리소스 식별자 생성
/members --------> /members/100 

응답 데이터
HTTP/1.1 201 OK
Content-Type: application/json
Content-Length: 34
Location: /members/100

{
  "username": "young"
  "age": 20
}
//201로 보냄(200도 가능) 자원이 생성된 경로는 location으로 보냄.

요청 데이터를 어떻게 처리한다는 걸까..? 예
- 스펙: 대상 리소스가 리소스의 고유한 의미 체계에 따라 요청에 포함된 표현을 처리하도록 요청합니다.
HTML: 양식에 입력된 필드와 같은 데이터 블록을 데이터 처리 프로세스에 제공
	HTML FORM에 입력한 정보로 회원 가입, 주문 등에서 사용
게시판, 뉴스그룹, 메일링 리스트, 블로그, 유사한 기사 그룹에 메시지 게시 등
	게시판 글쓰기, 댓글 달기..
서버가 아직 식별하지 않은 새 리소스 생성
	신규 주문 생성
기존 자원에 데이터 추가
	한 문서 끝에 내용 추가하기

정리
: 리소스 URI에 POST 요청이 오면 요청 데이터를 어떻게 처리할지 리소스마다 따로 정해야 함.
1. 새 리소스 생성(등록)
: 서버가 아직 식별하지 않은 새 리소스 생성
2. 요청 데이터 처리
- 단순히 데이터를 생성하거나, 변경하는 것을 넘어서 프로세스를 처리해야 하는 경우
	주문에서 결제 완료 -> 배달 시작 -> 배달 완료처럼 단순히 값 변경을 넘어 프로세스의 상태가 변경되는 경우
- POST 결과로 새로운 리소스가 생성되지 않을 수 있음.
	POST /orders/{orderId}/start-delivery (동사가 URI를 생성하는 경우 -> 컨트롤 URI)
3. 다른 메서드로 처리하기 애매한 경우
- EX) JSON으로 조회 데이터를 넘겨야 하는데 GET메서드를 사용하기 어려운 경우
(GET메서드를 지원하지 않는 서버가 많음/조회인 경우에도 POST 사용하면 됨)
- 애매하면 POST

- 메시지를 내부에 담아서 보내는 모든 걸 할 수 있지만, 
조회할 때는 GET이 유리함. 조회에는 최대한 GET을 쓰자 그 외는 POST

PUT
: 리소스를 대체
- 리소스가 있으면 대체, 없으면 생성
- 쉽게 이야기하면 덮어버린다.
!클라이언트가 리소스를 식별함!
- 클라이언트가 리소스 위치를 알고 URI를 지정함 --> POST와의 차이점
(POST는 데이터만 전달/서버가 위치를 지정하기 때문에 클라이언트는 리소스 위치를 알지 못함.)
---------------------------------------------
리소스가 있는 경우1.
[클라이언트]
PUT /members/100 HTTP/1.1
Content-Type: application/json

{
  "username": "old"
  "age": 50
}

/members/100
{
  "username": "young"
  "age": 20
}

--------------------------------------------------------
리소스 대체
/members/100
{
  "username": "old"
  "age": 50
}



!!완전히 대체한다!!
PUT /members/100 HTTP/1.1
Content-Type: application/json

{
  "age": 50
}

/members/100
{
  "username": "young"
  "age": 20
}
----------->
/members/100
{
  "age": 50
}

 기존 리소스는 삭제하고, 새로 생성함. username필드가 삭제됨.

PATCH
: 리소스 부분 변경
PATCH /members/100 HTTP/1.1
Content-Type: application/json

{
  "age": 50
}

/members/100
{
  "username": "young"
  "age": 20
}
----------->
/members/100
{
  "username": "young"
  "age": 50
}
CF. PATCH가 지원되지 않는 서버는 POST를 쓰자~

DELETE
:리소스 제거
DELETE /members/100 HTTP/1.1
Content-Type: application/json

HTTP메서드의 속성
- 안전(Safe Methods)
- 멱등(Idempotent Methods)
- 캐시가능(Cacheable Methods)

1. 안전
- 호출해도 리소스를 변경하지 않는다.
get->단순히 조회만 함. 변경이 일어나지 않음. 안전함.
post -> 변경이 일어남. 안전하지 않음.
만약 계속 호출해서 로그 같은 게 쌓여서 장애가 발생하면?
- 안전은 리소스만 고려함..그런 부분은 고려하지 않음.

2. 멱등
f(f(x))=f(x)
- 몇 번을 호출하든 결과가 똑같다.
get은 한 번 조회하든 100번 조회하든 같은 결과가 조회됨.
put: 결과를 대체함. 같은 요청을 여러 번 해도 최종 결과는 같음.
delete: 결과를 삭제함. 같은 요청을 여러 번 해도 삭제된 결과는 똑같음.
post: 멱등 아님. 두 번 호출하면 같은 결제가 중복해서 발생할 수 있음.
활용
-> 자동 복구 메커니즘
- 서버가 정상 응답을 못줬을 때, 클라이언트가 같은 요청을 다시 해도 되는가에 대한 판단 근거

재요청 중간에 다른 곳으로 리소스를 변경해버리면?
get -> username:A, age:20
put -> username:A, age:30
get -> username:A, age:30
-> 멱등은 외부 요인으로 중간에 리소스가 변경되는 것까지는 고려하지 않음.
// 멱등하지 않다고 판단하는 게 맞음.(서버에서 체크해야 함.)

3. 캐시 가능
- 응답 결과 리소스를 캐시해서 사용해도 되는가?
GET, HEAD, POST, PATCH 캐시 가능
실제로는 GET, HEAD 정도만 캐시로 사용
POST, PATCH는 본문 내용까지 캐시 키로 고려해야 하는데, 구현이 쉽지 않음.
예
웹브라우저가 이 이미지를 내부에 저장하고 있을 수 있는가로 판단
//나중에 추가 설명해주신대용


